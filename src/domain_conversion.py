# src/domain_conversion.py
import os
import numpy as np
from scipy.interpolate import interp1d
from tqdm import tqdm

# Try to import numba for faster resampling
try:
    from numba import njit, prange

    _NUMBA_AVAILABLE = True
except Exception:
    _NUMBA_AVAILABLE = False


def convert_depth_to_twt(vp_depth, dz):
    """
    Converts a depth-domain velocity cube to an irregular TWT cube.

    Args:
        vp_depth (np.ndarray): 3D P-wave velocity cube in the depth domain.
        dz (float): The vertical cell size in meters.

    Returns:
        np.ndarray: A 3D cube where each cell value is the TWT at that depth.
    """
    print("Converting from depth to two-way time...")
    # Slowness is the reciprocal of velocity
    slowness = 1.0 / vp_depth

    # Integrate slowness over depth to get one-way time. This is done by a cumulative sum.
    one_way_time = np.cumsum(slowness * dz, axis=-1)

    # Two-way time is the round trip
    twt_irregular = 2 * one_way_time
    return twt_irregular


def resample_properties_to_time(properties_depth, twt_irregular, dt):
    """
    Resamples all property cubes from the depth domain to a regular time grid.

    Args:
        properties_depth (dict): Dictionary of 3D property cubes in depth.
        twt_irregular (np.ndarray): The TWT cube generated by convert_depth_to_twt.
        dt (float): The desired regular time sampling interval in seconds.

    Returns:
        tuple: A dictionary of resampled 3D property cubes and the new time axis.
    """
    ni, nj, _ = properties_depth["vp"].shape
    max_twt = np.max(twt_irregular)
    time_axis = np.arange(0, max_twt, dt)

    resampled_properties = {
        key: np.zeros((ni, nj, len(time_axis))) for key in properties_depth
    }

    # If numba is available and enabled, use a compiled nearest-neighbor resampler
    use_numba = os.environ.get("RESAMPLE_USE_NUMBA", "1") == "1" and _NUMBA_AVAILABLE
    if use_numba:
        # Use a parallel numba kernel that walks each trace with a two-pointer
        # approach (O(nz+nt) per trace) which is very efficient and avoids
        # Python overhead for large grids.
        @njit(parallel=True)
        def _resample_numba(twt_ir, props, t_axis, out):
            ni, nj, nz = props.shape
            nt = t_axis.shape[0]
            for ii in prange(ni):
                for jj in range(nj):
                    twt = twt_ir[ii, jj]
                    prop = props[ii, jj]
                    k = 0
                    for ti in range(nt):
                        t = t_axis[ti]
                        # advance k while next sample is still less than t
                        while k + 1 < nz and twt[k + 1] < t:
                            k += 1
                        # choose nearest between k and k+1
                        if k + 1 < nz:
                            if abs(twt[k] - t) <= abs(twt[k + 1] - t):
                                out[ii, jj, ti] = prop[k]
                            else:
                                out[ii, jj, ti] = prop[k + 1]
                        else:
                            out[ii, jj, ti] = prop[k]

        print("Resampling properties onto regular time grid (numba-parallel)")
        for key, cube in properties_depth.items():
            out = np.zeros((ni, nj, len(time_axis)), dtype=cube.dtype)
            _resample_numba(twt_irregular, cube, time_axis, out)
            resampled_properties[key] = out
        return resampled_properties, time_axis

    # Fallback: SciPy interp1d per-trace (single-threaded)
    print("Resampling properties onto regular time grid (CPU interp1d)")
    # Iterate over each vertical trace (i, j)
    for i in tqdm(range(ni), desc="Resampling Traces"):
        for j in range(nj):
            twt_trace = twt_irregular[i, j, :]
            for key, cube in properties_depth.items():
                prop_trace = cube[i, j, :]
                # Create a 1D interpolation function for this trace (time -> property value)
                # 'nearest' preserves sharp boundaries, which is good for reflectivity.
                interp_func = interp1d(
                    twt_trace,
                    prop_trace,
                    kind="nearest",
                    bounds_error=False,
                    fill_value="extrapolate",
                )
                # Evaluate the function at the new regular time samples
                resampled_properties[key][i, j, :] = interp_func(time_axis)
    # Return the resampled property cubes and the regular time axis
    return resampled_properties, time_axis
